//   Author abt280200
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cctype>
#include <string>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <algorithm> 
#include <functional>
#include <unordered_map>
#include <unordered_set>
#include  <ctime>
#include <iomanip>
#include <bitset>
#include <assert.h>   
using namespace std;
 
#define ll                  long long int
#define uint                  unsigned long long int
#define count_1(n)            __builtin_popcountint(n)
#define pb                    push_back
#define eb                    emplace_back
#define ab(a)                 (a<0)?(-1*a):a
#define pc                    putchar
#define gc                    getchar
#define rep(i,n)     for (ll i = 0; i< n; i++)
#define mset(a,b,c)           loop(i,0,b) a[i]=c
#define mp                    make_pair
#define itoc(c)               ((char)(((int)'0')+c))
#define aint(p)                p.begin(),p.end()
#define max(x,y)              ((x>y)?x:y)
#define min(x,y)              ((x<y)?x:y)
#define mid(s,e)              (s+(e-s)/2)
#define vi                    vector<int> a
#define vvi                   vector<vector<int>>
const int MOD = 1e9 + 7;
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define reunique(v) v.resize(std::unique(v.begin(), v.end()) - v.begin())
#define sz(v) ((int)(v).size())


void maxSubArraySum(ll a[], ll size) 
{ 
    ll max_so_far =MOD,  max_ending_here = 0; 
    for (int i = 1; i < size; i++) 
    { 
        max_ending_here = max_ending_here + a[i];
        
        if (max_so_far < max_ending_here) {
            max_so_far = max_ending_here; 
        cout<<max_ending_here<<" ";}
  
        if (max_ending_here < 0) {
            max_ending_here = 0; 
            cout<<max_ending_here<<" ";}
    } 
     
} 
ll lcm(ll a,ll b)
{
            return a*b/__gcd(a,b);
}

void SieveOfEratosthenes(int  n , int k)
{
    
    bool prime[n + 1];
    memset(prime, true, sizeof(prime));
 
    for (int p = 2; p * p <= n; p=p+k)
    {
        
        if (prime[p] == true) 
        {
       
            for (int i = p * p; i <= n; i =i+k)
                prime[i] = false;
        }
    }
 
    
    ll vv=1;
    ll m=0;
    for (int p = 2; p <= n; p++)
        if (prime[p] &&m<=2){
                    m++;
             vv*=p;
             
        }
            cout << vv<<endl;
}
bool isprime(ll n){
            
if(n<=1)
return false;
for(ll i=2;i<=sqrt(n);i++)
if(n%i==0)
return false;
return true;
            
}
  ll modpower(ll a,ll b)
  {
              ll res=1;
              
              a=a%MOD;
              if(a==0)
              return 0;
              
              else
              {
                          while(b>0)
                          {
                               if(b%2!=0)
                               {
                                           res=(res*a)%MOD;
                                           
                               }
                               b=b/2; //b>>1; and b<<1 means b=b*2;
                               a=(a*a)%MOD;
                          }
                          return res;
                          
              }
  }
bool isPrime(ll n)
{
     int i = 2;
 
   
    if (n == 0 || n == 1) {
        return false;
    }
 
    
    if (n == i)
        return true;
 
    
    if (n % i == 0) {
        return false;
    }
    i++;
    return isPrime(n);
}



int binarySearch(int arr[], int l, int r, int x) 
{ 
    if (r >= l) { 
        int mid = l + (r - l) / 2; 
  
        if (arr[mid] == x) 
            return mid; 
  
        if (arr[mid] > x) 
            return binarySearch(arr, l, mid - 1, x); 
  
        return binarySearch(arr, mid + 1, r, x); 
    } 
  
    return -1; 
} 
 
        
 
 
 bool isPowerOfTwo(ll n)
{
   if(n==0)
   return false;
 
   return (ceil(log2(n)) == floor(log2(n)));
}

  
int lps(string str)
{
    int n = str.size();
 
    // Create a table to store
    // results of subproblems
    int L[n][n];
 
    // Strings of length 1
    // are palindrome of length 1
    for (int i = 0; i < n; i++)
        L[i][i] = 1;
 
    for (int cl = 2; cl <= n; cl++)
    {
        for (int i = 0; 
                 i < n - cl + 1; i++)
        {
            int j = i + cl - 1;
            if (str[i] == str[j] &&
                        cl == 2)
                L[i][j] = 2;
            else if (str[i] == str[j])
                L[i][j] = L[i + 1][j - 1] + 2;
            else
                L[i][j] = max(L[i][j - 1], 
                            L[i + 1][j]);
        }
    }
 
    
    return L[0][n - 1];
}

int getSum(int BITree[], int index)
{
	int sum = 0; // Initialize result

	// Traverse ancestors of BITree[index]
	while (index > 0)
	{
		// Add current element of BITree to sum
		sum += BITree[index];

		// Move index to parent node in getSum View
		index -= index & (-index);
	}
	return sum;
}


void updateBIT(int BITree[], int n, int index, int val)
{
	// Traverse all ancestors and add 'val'
	while (index <= n)
	{
	// Add 'val' to current node of BI Tree
	BITree[index] += val;

	// Update index to that of parent in update View
	index += index & (-index);
	}
}

void convert(ll arr[], ll n)
{
	// Create a copy of arrp[] in temp and sort the temp array
	// in increasing order
	int temp[n];
	for (int i=0; i<n; i++)
		temp[i] = arr[i];
	sort(temp, temp+n);

	// Traverse all array elements
	for (int i=0; i<n; i++)
	{
		// lower_bound() Returns pointer to the first element
		// greater than or equal to arr[i]
		arr[i] = lower_bound(temp, temp+n, arr[i]) - temp + 1;
	}
}
 const ll N = 2e5 + 5;

ll tree[4 * N];

 void build(ll a[], ll v, ll tl, ll tr) {
     if (tl == tr) {
        tree[v] = a[tl];
    } else {
        ll tm = (tl + tr) / 2;
        build(a, v * 2, tl, tm);
        build(a, v * 2 + 1, tm + 1, tr);
        tree[v] = min(tree[v * 2] , tree[v * 2 + 1]);
 
    }
}
void update(ll v, ll tl, ll tr, ll pos, ll new_val) {
    if (tl == tr) {
        tree[v] = new_val;
    } else {
        ll tm = (tl + tr) / 2;
        if (pos <= tm)
            update(v * 2, tl, tm, pos, new_val);
        else
            update(v * 2 + 1, tm + 1, tr, pos, new_val);
        tree[v] = tree[v * 2] + tree[v * 2 + 1];
    }
}
ll query(ll v, ll tl, ll tr, ll l, ll r, ll &to) {
    if (l > r)
        return 0;
    if (l == tl && r == tr) {
        to = min(to, tree[v]);
        return tree[v];
    }
    ll tm = (tl + tr) / 2;
    return min(query(v * 2, tl, tm, l, min(r, tm), to)
               , query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, to));
}
void rangebuild(ll a[], ll v, ll tl, ll tr) {
    if (tl == tr) {
        tree[v] = a[tr];
    } else {
        ll tm = (tl + tr) / 2;
        rangebuild(a, v * 2, tl, tm);
        rangebuild(a, v * 2 + 1, tm + 1, tr);
        tree[v] = 0;
    }
}
 
void rangeupdate(ll v, ll tl, ll tr, ll l, ll r, ll add) {
    if (l > r)
        return ;
    if (l == tl && r == tr) {
        tree[v] += (add);
    } else {
        ll tm = (tl + tr) / 2;
        rangeupdate(v * 2, tl, tm, l, min(r, tm), add);
        rangeupdate(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, add);
    }
}
 
ll rangeget(ll v, ll tl, ll tr, ll pos) {
    if (tl == tr)
        return tree[v];
    ll tm = (tl + tr) / 2;
    if (pos <= tm)
        return tree[v] + rangeget(v * 2, tl, tm, pos);
    else
        return tree[v] + rangeget(v * 2 + 1, tm + 1, tr, pos);
}

int Distinct_Prime_factors(vector<int> a) 
{ 
    
    unordered_set<int> m; 
  
    
    for (int i = 0; i < a.size(); i++) { 
        int sq = sqrt(a[i]); 
  
        
        for (int j = 2; j <= sq; j++) { 
            if (a[i] % j == 0) { 
  
                m.insert(j); 
  
                while (a[i] % j == 0) { 
                    a[i] /= j; 
                } 
            } 
        } 
  
        
        if (a[i] > 1) { 
            m.insert(a[i]); 
        } 
    } 
  
    return m.size(); 
}


 


   
 bool issubstring( string s,string t)
 {
    ll i,j,k,l,p,n,m;
    n=s.length();
    m=t.length();
    j=0;
    for(i=0;i<n&&j<m;i++)
    {
        if(s[i]==t[j])
        j++;
        
    }
   
   return j==m;
   
 }
 
 string gcdOfStrings(string str1, string str2) {
        while(1){
        if(str1==str2)
            return str1;
         if(str1+str2!=str2+str1)
            return "";
        if(str1.length()>str2.length())
        {
            str1=str1.substr(str2.length());
        }
         if(str2.length()>str1.length())
        {
           str2= str2.substr(str1.length());
            
        }
        }
        return "";
    }
    ll gcdof(ll a , ll b)
    {     
                ll temp;
                while(b>0)
                {
                 temp=a%b;
                 a=b;
                 b=temp;
                            
                }
                return a;
                
    }

  void solve()
  { 
              ll k,l,n,m,p,i,j,x,d,b;
              cin>>n>>m;
                if(n==0 || m==0)
                cout<<"0"<<endl;
                else if(n==1 && m!=1 || m==1 && n!=1 )
                cout<<"1"<<endl;
                else if(m>n*2 ||n>m*2)
                            cout<<min(n,m)<<endl;
                      else{
                k=(n+m)/3;
                cout<<k<<endl;
                
                }
           
          
  }

  int main()
{
            int t=1;
            //cin>>t;
          while(t--){
          solve();
          }
            return 0;
 }
  
  
      
  
 
